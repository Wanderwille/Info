# Nginx и Apache: Подробное Сравнение

## Apache HTTP Server

### 1. История и распространение
- **Apache** был выпущен в 1995 году и стал одним из первых широко распространенных веб-серверов.
- Он получил популярность благодаря своей модульной архитектуре и гибкости.

### 2. Архитектура
- Apache использует **модель процессов или потоков** для обработки запросов.
  - **MPM (Multi-Processing Modules)**: Основные модули, определяющие, как Apache обрабатывает соединения.
    - **Prefork**: Создает отдельный процесс для каждого соединения. Подходит для совместимости с устаревшими модулями, но потребляет больше памяти.
    - **Worker**: Создает потоки, что снижает потребление памяти и улучшает производительность.
    - **Event**: Оптимизирован для работы с большим количеством постоянных соединений, использует неблокирующие операции.

### 3. Конфигурируемость
- Apache поддерживает `.htaccess` файлы, которые позволяют управлять конфигурацией сервера на уровне директорий.
- Большое количество модулей, таких как `mod_rewrite`, `mod_ssl`, `mod_proxy`.

### 4. Производительность
- Apache хорошо справляется с низкими и средними нагрузками.
- Однако при высоких нагрузках, особенно для статического контента, Apache может уступать Nginx в производительности.

### 5. Гибкость
- Apache может быть настроен для различных сценариев использования благодаря множеству модулей и гибкости конфигурации.
- Широко поддерживается различными хостинг-провайдерами.

## Nginx

### 1. История и распространение
- **Nginx** был разработан в 2004 году Игорем Сысоевым для решения проблемы "C10k" (обработка 10,000 соединений одновременно).
- Быстро завоевал популярность благодаря своей высокой производительности и низкому потреблению ресурсов.

### 2. Архитектура
- Nginx использует **асинхронную и событийно-ориентированную архитектуру**.
  - Один процесс может обрабатывать тысячи соединений благодаря использованию механизма событий (event loop).
  - Это позволяет Nginx эффективно использовать ресурсы и поддерживать высокий уровень параллельности.

### 3. Производительность
- Nginx изначально был разработан для обработки статического контента и балансировки нагрузки.
- Очень быстро обрабатывает статические файлы (HTML, CSS, JavaScript, изображения).
- Часто используется как **обратный прокси** или **балансировщик нагрузки** для других серверов, включая Apache.

### 4. Конфигурация
- Nginx не использует `.htaccess`. Все настройки выполняются в центральном конфигурационном файле, что делает его быстрее, но менее гибким для изменения конфигурации пользователями на уровне отдельных директорий.
- Поддержка SSL, обратного проксирования, кэширования, сжатия и других функций через встроенные модули.

### 5. Модули и расширяемость
- Модули в Nginx чаще всего компилируются вместе с сервером, что улучшает производительность, но делает сервер менее гибким по сравнению с Apache.
- Существует несколько версий Nginx: бесплатная версия с открытым исходным кодом и коммерческая версия **Nginx Plus**, которая включает дополнительные функции.

## Сравнение Nginx и Apache

| **Характеристика**           | **Apache**                             | **Nginx**                          |
|------------------------------|----------------------------------------|------------------------------------|
| **Архитектура**               | Процесс/потоки                         | Асинхронная, событийно-ориентированная |
| **Производительность**        | Хорош для динамических сайтов, средних нагрузок | Отлично справляется с высокими нагрузками и статическим контентом |
| **Конфигурация**              | Поддержка `.htaccess`                  | Центральная конфигурация           |
| **Модули**                    | Динамические модули                    | Модули компилируются                |
| **Ресурсоемкость**            | Высокая при больших нагрузках          | Низкая, оптимизирован для многозадачности |
| **Использование**             | Преимущественно для динамических сайтов | Часто используется как прокси или балансировщик |
| **SSL/TLS**                   | Через `mod_ssl`                        | Встроенная поддержка               |

Оба сервера активно развиваются и имеют свои преимущества в зависимости от конкретных задач и нагрузки на сервер.


## Теперь нужно разобраться в базовых конфигурциях nginx и apache

### Простые Директивы и Параметры для Nginx и Apache

### Простые директивы для Nginx

1. **`listen`**  
   Указывает порт и адрес, на котором сервер будет слушать входящие соединения.
   ```nginx
   listen 80;  # Слушает порт 80 (по умолчанию для HTTP)
   listen 443 ssl;  # Слушает порт 443 для HTTPS
   ```

2. **`server_name`**  
   Определяет доменные имена, которые будут обрабатываться этим серверным блоком.
   ```nginx
   server_name example.com www.example.com;
   ```

3. **`location`**  
   Используется для указания правил обработки запросов в определенных путях.
   ```nginx
   location / {
       root /var/www/html;
       index index.html index.htm;
   }
   ```

4. **`root`**  
   Указывает корневую директорию, откуда сервер будет обслуживать файлы.
   ```nginx
   root /var/www/html;
   ```

5. **`index`**  
   Определяет файл, который будет использоваться как главная страница каталога.
   ```nginx
   index index.html index.htm;
   ```

6. **`error_page`**  
   Устанавливает пользовательские страницы ошибок для определенных кодов HTTP.
   ```nginx
   error_page 404 /custom_404.html;
   ```

## Простые директивы для Apache

1. **`Listen`**  
   Указывает порт и адрес, на котором сервер будет слушать входящие соединения.
   ```apache
   Listen 80  # Слушает порт 80
   Listen 443  # Слушает порт 443 для HTTPS
   ```

2. **`ServerName`**  
   Определяет основное доменное имя, связанное с этим сервером.
   ```apache
   ServerName example.com
   ```

3. **`DocumentRoot`**  
   Указывает директорию, откуда сервер будет обслуживать файлы.
   ```apache
   DocumentRoot "/var/www/html"
   ```

4. **`DirectoryIndex`**  
   Определяет, какие файлы будут использоваться в качестве индекса (главной страницы) каталога.
   ```apache
   DirectoryIndex index.html index.htm
   ```

5. **`ErrorDocument`**  
   Устанавливает пользовательские страницы ошибок для определенных кодов HTTP.
   ```apache
   ErrorDocument 404 /custom_404.html
   ```

6. **`<Directory>`**  
   Блок директив для указания параметров доступа к определенным каталогам.
   ```apache
   <Directory "/var/www/html">
       Options Indexes FollowSymLinks
       AllowOverride All
       Require all granted
   </Directory>
   ```

Тут мы разобрали максимально базовые параметры: 

Пример конфигурации Apache, который выступает в качестве веб-сервера, для обработки запросов с Docker контейнера:

```bash
<IfModule mod_ssl.c>
<VirtualHost *:443>
    ServerName glitchtip.webest.ru

    ProxyPreserveHost On
    ProxyPass / http://localhost:8000/
    ProxyPassReverse / http://localhost:8000/
    RequestHeader set X-Forwarded-Proto "https"
    RequestHeader set X-Forwarded-Ssl "on"
    RequestHeader set X-Forwarded-Host "glitchtip.webest.ru"    

    ProxyTimeout 60
    Timeout 60

    ErrorLog ${APACHE_LOG_DIR}/glitch_error.log
    CustomLog ${APACHE_LOG_DIR}/glitch_access.log combined
RewriteEngine on
# Some rewrite rules in this file were disabled on your HTTPS site,
# because they have the potential to create redirection loops.

# RewriteCond %{SERVER_NAME} =glitchtip.webest.ru
# RewriteRule ^ https://%{SERVER_NAME}%{REQUEST_URI} [END,NE,R=permanent]

SSLCertificateFile /etc/letsencrypt/live/glitchtip.webest.ru/fullchain.pem
SSLCertificateKeyFile /etc/letsencrypt/live/glitchtip.webest.ru/privkey.pem
Include /etc/letsencrypt/options-ssl-apache.conf
</VirtualHost>
</IfModule>
```


И так же посмотрим конфигурацию для nginx, в качестве прокси на Docker контейнер:

```
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}


server {
    listen 80;
    server_name grafana.webest.ru;

    location ~/ {
        proxy_pass http://127.0.0.1:3000;
        proxy_set_header Host $host;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
      }
}
```

Порой возникает проблема, что они оба находятся в системе и один из них не работает, проблема в том, что они оба работают на 80 и 443 порту, если же такое случается, то один из них можно либо остановить, либо перевести на другой порт, например в Bitrix, это порт 8080(как один из примеров), в этот момент nginx является и как веб сервер и как прокси. Он обрабатывает запросы с apache, выступая при этом прокси сервером (в битрикс конфигурациях apache называется  httpd) 

